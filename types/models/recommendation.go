package models

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"suasor/clients/media/types"
	"time"
)

type RecommendationSource string

const (
	// RecommendationSourceAI recommendation was generated by an AI model
	RecommendationSourceAI RecommendationSource = "ai"
	// RecommendationSourceSystem recommendation was generated systematically by the application
	RecommendationSourceSystem RecommendationSource = "system"
	// RecommendationSourceManual recommendation was manually added
	RecommendationSourceManual RecommendationSource = "manual"
)

// Recommendation represents a media recommendation for a user
// @Description Media recommendation stored in the database
type Recommendation struct {
	BaseModel
	UserID           uint64          `json:"userID" gorm:"index;not null"`
	MediaItemID      uint64          `json:"mediaItemID" gorm:"index"`
	MediaType        types.MediaType `json:"mediaType" gorm:"index;not null"` // "movie", "series", "music"
	Title            string          `json:"title" gorm:"not null"`
	Year             int             `json:"year,omitempty"`
	Genres           StringArray     `json:"genres" gorm:"type:jsonb;serializer:json"`
	Reasoning        string          `json:"reasoning" gorm:"type:text"`
	SimilarItems     StringArray     `json:"similarItems" gorm:"type:jsonb;serializer:json"`
	MatchesActors    StringArray     `json:"matchesActors" gorm:"type:jsonb;serializer:json"`
	MatchesDirectors StringArray     `json:"matchesDirectors" gorm:"type:jsonb;serializer:json"`
	MatchesGenres    StringArray     `json:"matchesGenres" gorm:"type:jsonb;serializer:json"`
	RecommendedBy    string          `json:"recommendedBy" gorm:"not null"` // "AI", "popular", "similar_users"
	AIModel          string          `json:"aiModel,omitempty"`             // AI model used if recommendedBy="AI"
	JobRunID         uint64          `json:"jobRunID,omitempty"`            // Job run that created this recommendation
	CreatedAt        time.Time       `json:"createdAt" gorm:"not null"`
	ExpiresAt        *time.Time      `json:"expiresAt,omitempty"`           // When this recommendation expires
	IsViewed         bool            `json:"isViewed" gorm:"default:false"` // Whether user has viewed this item
	UserRating       float32         `json:"userRating" gorm:"default:0"`   // If user has rated this recommendation
	ExternalIDs      *ExternalIDMap  `json:"externalIDs" gorm:"type:jsonb;serializer:json"`
	// Source of the recommendation (AI, system, manual)
	Source RecommendationSource `json:"source" gorm:"index;not null"`
	// ID of the client that generated this recommendation, if applicable
	SourceClientID *uint64 `json:"sourceClientID" gorm:"index"`
	// Type of the client that generated this recommendation
	SourceClientType string `json:"sourceClientType"`
	// Confidence score (0.0 to 1.0) if available
	Confidence float32 `json:"confidence"`
	// Whether this item is present in the user's library
	InLibrary bool `json:"inLibrary" gorm:"index"`
	// Whether this item has been dismissed by the user
	Dismissed bool `json:"dismissed" gorm:"index;default:false"`
	// Whether this is an active recommendation
	Active bool `json:"active" gorm:"index;default:true"`
	// Additional metadata (stored as JSON)
	Metadata string `json:"metadata" gorm:"type:jsonb"`
}

// StringArray is a string array for JSONB storage
type StringArray []string

// Value implements the driver.Valuer interface for StringArray
func (a StringArray) Value() (driver.Value, error) {
	return json.Marshal(a)
}

// Scan implements the sql.Scanner interface for StringArray
func (a *StringArray) Scan(value any) error {
	b, ok := value.([]byte)
	if !ok {
		return errors.New("type assertion to []byte failed")
	}
	return json.Unmarshal(b, &a)
}

// ExternalIDMap stores external IDs in a map for easy lookup
type ExternalIDMap map[string]string

// Value implements the driver.Valuer interface for ExternalIDMap
func (m ExternalIDMap) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Scan implements the sql.Scanner interface for ExternalIDMap
func (m *ExternalIDMap) Scan(value interface{}) error {
	b, ok := value.([]byte)
	if !ok {
		return errors.New("type assertion to []byte failed")
	}
	return json.Unmarshal(b, &m)
}
